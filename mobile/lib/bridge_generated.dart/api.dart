// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `enqueue_send`, `ensure_recipient_dm_relays`, `event_p_tag_pubkey`, `get_client_and_keys`, `get_nip44_conversation_key`, `hmac_sha256`, `is_read_receipt_content`, `next_send_seq`, `nip44_calc_padded_len`, `nip44_decrypt_custom`, `nip44_encrypt_custom`, `nip44_fast_expand`, `nip44_hmac_aad`, `nip44_pad`, `nip44_unpad`, `normalize_message_content`, `parse_pubkey`, `parse_read_receipt_id`, `random_timestamp_within_two_days`, `relay_tags`, `run_block_on`, `send_dm_direct`, `send_gift_dm_direct`, `seq_from_event_tags`, `seq_from_tag_list`, `sha256_hex`, `start_send_worker`, `strip_pushstr_client_tag`, `timestamp`, `unwrap_gift_event`, `upload_to_blossom`, `wrap_gift_event`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `Nip44MessageKeys`, `RumorData`, `SendKind`, `SendRequest`, `UnwrappedGift`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Initialize the Nostr service with a secret key (nsec)
/// If nsec is empty, generates a new key
/// Returns npub
String initNostr({required String nsec}) => RustLib.instance.api.crateApiInitNostr(nsec: nsec);

/// Get the current user's npub
String getNpub() => RustLib.instance.api.crateApiGetNpub();

/// Get the current user's nsec (for backup purposes)
String getNsec() => RustLib.instance.api.crateApiGetNsec();

/// Generate a new keypair and return nsec
String generateNewKey() => RustLib.instance.api.crateApiGenerateNewKey();

/// Send a giftwrapped DM (kind 1059 wrapping kind 4) using nip44 by default
String sendGiftDm({required String recipient, required String content, required bool useNip44}) =>
    RustLib.instance.api.crateApiSendGiftDm(recipient: recipient, content: content, useNip44: useNip44);

/// Send a giftwrap DM using the standard NIP-59 sealed rumor path.
String sendLegacyGiftDm({required String recipient, required String content}) =>
    RustLib.instance.api.crateApiSendLegacyGiftDm(recipient: recipient, content: content);

/// Wrap a NIP-17 giftwrap from a provided inner event JSON
String wrapGift({required String innerJson, required String recipient, required bool useNip44}) =>
    RustLib.instance.api.crateApiWrapGift(innerJson: innerJson, recipient: recipient, useNip44: useNip44);

/// Unwrap a NIP-17 giftwrap to recover the inner event
String unwrapGift({required String giftJson, String? myNsec}) =>
    RustLib.instance.api.crateApiUnwrapGift(giftJson: giftJson, myNsec: myNsec);

/// Convert npub to hex pubkey
String npubToHex({required String npub}) => RustLib.instance.api.crateApiNpubToHex(npub: npub);

/// Convert hex pubkey to npub
String hexToNpub({required String hex}) => RustLib.instance.api.crateApiHexToNpub(hex: hex);

/// Derive npubs for a list of nsecs without mutating global state.
List<String> deriveNpubs({required List<String> nsecs}) => RustLib.instance.api.crateApiDeriveNpubs(nsecs: nsecs);

/// Send an encrypted DM using NIP-04 (kind 4) - matches browser extension default
/// recipient can be npub or hex pubkey
/// Returns event ID
String sendDm({required String recipient, required String message}) =>
    RustLib.instance.api.crateApiSendDm(recipient: recipient, message: message);

/// Fetch recent giftwrap DMs and return as JSON array
/// Fetches kind 1059 addressed to us, unwraps inner event
/// Each message contains: id, from, to, content (plaintext), created_at, direction
String fetchRecentDms({required BigInt limit, required BigInt sinceTimestamp}) =>
    RustLib.instance.api.crateApiFetchRecentDms(limit: limit, sinceTimestamp: sinceTimestamp);

/// Listen for new DMs and return them as JSON
/// This is a blocking call that waits for timeout_secs
/// Returns new messages that haven't been returned before
String waitForNewDms({required BigInt timeoutSecs}) =>
    RustLib.instance.api.crateApiWaitForNewDms(timeoutSecs: timeoutSecs);

/// Encrypt media and upload to Blossom, returning a descriptor
MediaDescriptor encryptMedia({
  required List<int> bytes,
  required String recipient,
  required String mime,
  String? filename,
}) => RustLib.instance.api.crateApiEncryptMedia(bytes: bytes, recipient: recipient, mime: mime, filename: filename);

/// Upload unencrypted media to Blossom and return a descriptor.
MediaDescriptor uploadMediaUnencrypted({required List<int> bytes, required String mime, String? filename}) =>
    RustLib.instance.api.crateApiUploadMediaUnencrypted(bytes: bytes, mime: mime, filename: filename);

/// Decrypt media descriptor to raw bytes using provided or current key
/// sender_pubkey: hex or npub of the message sender (for deriving shared secret)
Uint8List decryptMedia({required String descriptorJson, required String senderPubkey, String? myNsec}) => RustLib
    .instance
    .api
    .crateApiDecryptMedia(descriptorJson: descriptorJson, senderPubkey: senderPubkey, myNsec: myNsec);

/// Clear the cache of returned event IDs
void clearReturnedEventsCache() => RustLib.instance.api.crateApiClearReturnedEventsCache();

class MediaDescriptor {
  final String url;
  final String iv;
  final String sha256;
  final String cipherSha256;
  final String mime;
  final BigInt size;
  final String encryption;
  final String? filename;

  const MediaDescriptor({
    required this.url,
    required this.iv,
    required this.sha256,
    required this.cipherSha256,
    required this.mime,
    required this.size,
    required this.encryption,
    this.filename,
  });

  @override
  int get hashCode =>
      url.hashCode ^
      iv.hashCode ^
      sha256.hashCode ^
      cipherSha256.hashCode ^
      mime.hashCode ^
      size.hashCode ^
      encryption.hashCode ^
      filename.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaDescriptor &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          iv == other.iv &&
          sha256 == other.sha256 &&
          cipherSha256 == other.cipherSha256 &&
          mime == other.mime &&
          size == other.size &&
          encryption == other.encryption &&
          filename == other.filename;
}
