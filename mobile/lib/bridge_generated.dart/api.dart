// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_client_and_keys`, `get_nip44_conversation_key`, `gunzip_bytes`, `gzip_bytes`, `nip44_decrypt_custom`, `nip44_encrypt_custom`, `parse_pubkey`, `sha256_hex`, `timestamp`, `unwrap_gift_event`, `upload_to_blossom`, `wrap_gift_event`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Initialize the Nostr service with a secret key (nsec)
/// If nsec is empty, generates a new key
/// Returns npub
String initNostr({required String nsec}) => RustLib.instance.api.crateApiInitNostr(nsec: nsec);

/// Get the current user's npub
String getNpub() => RustLib.instance.api.crateApiGetNpub();

/// Get the current user's nsec (for backup purposes)
String getNsec() => RustLib.instance.api.crateApiGetNsec();

/// Generate a new keypair and return nsec
String generateNewKey() => RustLib.instance.api.crateApiGenerateNewKey();

/// Send a giftwrapped DM (kind 1059 wrapping kind 4) using nip44 by default
String sendGiftDm({required String recipient, required String content, required bool useNip44}) =>
    RustLib.instance.api.crateApiSendGiftDm(recipient: recipient, content: content, useNip44: useNip44);

/// Send a legacy giftwrap DM compatible with the browser extension
String sendLegacyGiftDm({required String recipient, required String content}) =>
    RustLib.instance.api.crateApiSendLegacyGiftDm(recipient: recipient, content: content);

/// Wrap a NIP-17 giftwrap from a provided inner event JSON
String wrapGift({required String innerJson, required String recipient, required bool useNip44}) =>
    RustLib.instance.api.crateApiWrapGift(innerJson: innerJson, recipient: recipient, useNip44: useNip44);

/// Unwrap a NIP-17 giftwrap to recover the inner event
String unwrapGift({required String giftJson, String? myNsec}) =>
    RustLib.instance.api.crateApiUnwrapGift(giftJson: giftJson, myNsec: myNsec);

/// Convert npub to hex pubkey
String npubToHex({required String npub}) => RustLib.instance.api.crateApiNpubToHex(npub: npub);

/// Convert hex pubkey to npub
String hexToNpub({required String hex}) => RustLib.instance.api.crateApiHexToNpub(hex: hex);

/// Send an encrypted DM using NIP-04 (kind 4) - matches browser extension default
/// recipient can be npub or hex pubkey
/// Returns event ID
String sendDm({required String recipient, required String message}) =>
    RustLib.instance.api.crateApiSendDm(recipient: recipient, message: message);

/// Fetch recent giftwrap DMs and return as JSON array
/// Fetches kind 1059 addressed to us, unwraps inner event
/// Each message contains: id, from, to, content (plaintext), created_at, direction
String fetchRecentDms({required BigInt limit, required BigInt sinceTimestamp}) =>
    RustLib.instance.api.crateApiFetchRecentDms(limit: limit, sinceTimestamp: sinceTimestamp);

/// Listen for new DMs and return them as JSON
/// This is a blocking call that waits for timeout_secs
/// Returns new messages that haven't been returned before
String waitForNewDms({required BigInt timeoutSecs}) =>
    RustLib.instance.api.crateApiWaitForNewDms(timeoutSecs: timeoutSecs);

/// Encrypt media and upload to Blossom, returning a descriptor
MediaDescriptor encryptMedia({
  required List<int> bytes,
  required String recipient,
  required String mime,
  String? filename,
}) => RustLib.instance.api.crateApiEncryptMedia(bytes: bytes, recipient: recipient, mime: mime, filename: filename);

/// Decrypt media descriptor to raw bytes using provided or current key
/// sender_pubkey: hex or npub of the message sender (for deriving shared secret)
Uint8List decryptMedia({required String descriptorJson, required String senderPubkey, String? myNsec}) => RustLib
    .instance
    .api
    .crateApiDecryptMedia(descriptorJson: descriptorJson, senderPubkey: senderPubkey, myNsec: myNsec);

/// Clear the cache of returned event IDs
void clearReturnedEventsCache() => RustLib.instance.api.crateApiClearReturnedEventsCache();

class MediaDescriptor {
  final String url;
  final String iv;
  final String sha256;
  final String cipherSha256;
  final String mime;
  final BigInt size;
  final String encryption;
  final String? filename;

  const MediaDescriptor({
    required this.url,
    required this.iv,
    required this.sha256,
    required this.cipherSha256,
    required this.mime,
    required this.size,
    required this.encryption,
    this.filename,
  });

  @override
  int get hashCode =>
      url.hashCode ^
      iv.hashCode ^
      sha256.hashCode ^
      cipherSha256.hashCode ^
      mime.hashCode ^
      size.hashCode ^
      encryption.hashCode ^
      filename.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaDescriptor &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          iv == other.iv &&
          sha256 == other.sha256 &&
          cipherSha256 == other.cipherSha256 &&
          mime == other.mime &&
          size == other.size &&
          encryption == other.encryption &&
          filename == other.filename;
}
